use core::fmt::Debug;
use serde::Serialize;
use std::time::{Duration, Instant};

pub use serde;
pub use wasmi_profiling_macro::WasmiProfiling;

/// Implemented by the generated instruction data to compute the total time spent executing instructions.
pub trait InstrsTotalTime {
    /// Returns the total amount of time spent executing instructions.
    fn instrs_total_time(&self) -> Duration;
}

/// Implemented by the generated instruction data to compute number of executed instructions.
pub trait InstrsCount {
    /// Returns the total amount of instructions executed.
    fn instrs_count(&self) -> u64;
}

/// Derived and implemented by the Wasmi instruction type to track profiling data during execution.
pub trait Profiling {
    /// The profiling struct holding all relevant data.
    type InstrData: Debug + Default + Copy + Clone + Serialize + InstrsCount + InstrsTotalTime;

    /// Creates a new [`ProfilingData`] with default values.
    fn new() -> ProfilingData<Self::InstrData>;
}

/// Type to collect profiling data.
///
/// Generic over the type representing the Wasmi instructions which is generated by a macro.
#[derive(Debug, Default, Copy, Clone, Serialize)]
pub struct ProfilingData<T> {
    /// Profiling data for Wasmi instruction dispatch.
    pub dispatch: DispatchTracker,
    /// Profiling data for host function calls.
    pub host: InstrTracker,
    /// Profiling data for Wasmi bytecode instructions.
    pub instr: T,
}

/// A tracker of profiling data for dispatching of Wasmi bytecode.
#[derive(Debug, Default, Copy, Clone, Serialize)]
pub struct DispatchTracker {
    /// Measures the time spent during bytecode dispatch.
    watch: StopWatch,
}

impl DispatchTracker {
    /// Start Wasmi bytecode dispatch measurement.
    pub fn start_dispatch(&mut self) {
        self.watch.start();
    }

    /// End Wasmi bytecode dispatch measurement.
    pub fn end_dispatch(&mut self) {
        self.watch.stop();
    }

    /// Returns the total time spent dispatching Wasmi bytecode.
    pub fn total_time(&self) -> Duration {
        self.watch.total()
    }
}

/// A tracker of profiling data for a single type of instruction.
#[derive(Debug, Default, Copy, Clone, Serialize)]
pub struct InstrTracker {
    /// The number of times the associated instruction got executed.
    executed: u64,
    /// Measures the time spent during execution of the associated instruction.
    watch: StopWatch,
}

impl InstrTracker {
    /// Start instruction execution measurement.
    pub fn start_execution(&mut self) {
        self.executed = self.executed.wrapping_add(1);
        self.watch.start();
    }

    /// End instruction execution measurement.
    pub fn end_execution(&mut self) {
        self.watch.stop();
    }

    /// Returns the times the associated instruction was executed.
    pub fn count(&self) -> u64 {
        self.executed
    }

    /// Returns the total time spent executing the associated instruction.
    pub fn total_time(&self) -> Duration {
        self.watch.total()
    }
}

#[derive(Debug, Default, Copy, Clone, Serialize)]
struct StopWatch {
    /// The start of the current measurement if any.
    #[serde(skip)]
    started: Option<Instant>,
    /// The total time elapsed while measuring with the [`StopWatch`].
    total: Duration,
}

impl StopWatch {
    /// Returns `true` if the [`StopWatch`] is measuring time.
    pub fn is_measuring(&self) -> bool {
        self.started.is_some()
    }

    /// Starts measuring time.
    pub fn start(&mut self) {
        debug_assert!(!self.is_measuring());
        self.started = Some(Instant::now());
    }

    /// Stops measuring time and returns the elapsed time since the start of measurement.
    pub fn stop(&mut self) -> Duration {
        let Some(started) = self.started.take() else {
            panic!("called `stop` without `start` for `StopWatch`")
        };
        let elapsed = started.elapsed();
        self.total = self.total.checked_add(elapsed).unwrap_or_else(|| {
            panic!(
                "`total_time` overflowed for `StopWatch`: self.total_time = {:?}, elapsed = {:?}",
                self.total, elapsed
            );
        });
        elapsed
    }

    /// Returns the total time elapsed for the [`StopWatch`] measurements.
    pub fn total(&self) -> Duration {
        debug_assert!(!self.is_measuring());
        self.total
    }
}
